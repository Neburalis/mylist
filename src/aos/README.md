# mylist_aos — интерфейс и отличия AOS-реализации

Этот файл документирует публичный интерфейс, объявленный в `list/src/aos/list_aos.h`, и чётко разделяет
то, что является общим (портируемым) API списка, и то, что специфично для текущей AOS-реализации.

Файл заголовка: `list/src/aos/list_aos.h`

## Кратко

- Общий интерфейс описывает операции над списком (конструктор/деструктор, чтение размера/ёмкости, вставки/удаления,
  навигацию и пр.). Эти функции и их семантика — пользуются смыслом независимо от конкретной реализации.
- AOS-реализация (Array-Of-Structs, индексная модель с sentinel-элементом в `elements[0]`) содержит
  детали реализации и расширения (enum `LIST_ERRNO`, внутренняя организация `list_element_t`, `free_idx`
  и т.п.). Эти детали не обязательны для API совместимости и считаются специфичными для
  данной реализации.

## Что является общим интерфейсом (портируемые части API)

Следующие элементы интерфейса предназначены для использования клиентским кодом и, по смыслу, могут
быть реализованы в любой реализации списка (AOS, linked-list, vector-backed и т.д.):

- Конструктор/деструктор:
  - `list_t * constructor(size_t capacity);`
  - `void destructor(list_t **list_ptr);`

- Проверка/диагностика:
  - `bool verifier(list_t *list);` — проверить инварианты структуры.
  - `const char *error(list_t *list);` — получить описание последней ошибки (зависит от реализации, но сама идея — общая).

- Свойства и навигация:
  - `bool empty(list_t *list);`
  - `size_t size(list_t *list);`
  - `size_t capacity(list_t *list);`
  - `size_t front(list_t *list);` — логический индекс первого элемента (0 — отсутствует).
  - `size_t back(list_t *list);` — логический индекс последнего элемента (0 — отсутствует).
  - `size_t get_next_element(list_t *list, size_t element_idx);`
  - `size_t get_prev_element(list_t *list, size_t element_idx);`

- Модификаторы/операции над списком:
  - `insert`, `emplace`, `push_front`, `push_back`, `erase`, `pop_front`, `pop_back`, `swap`.
    Их семантика (вставить перед/после, удалить первое/последнее и т.д.) — часть общего контракта.

- Медленные/утилитные операции (логическая индексация, поиск):
  - `namespace slow { size_t index(list_t*, size_t logic_index); size_t search(list_t*, list_containing_t); }`
    (Эти операции объявлены в интерфейсе как «медленные», но концептуально они общие — реализация может иметь
     более эффективные альтернативы.)

- Дамп/логирование: макрос `dump(list, logfile, log_dirname, fmt, ...)`.
  - Идея: API даёт возможность отладочного дампа. Для генерации изображений используется dot из пакета graphviz, дамп сохраняется в logfile.html в котором визуализация через graphviz а также текстовое описание внутренего состояния.

Замечание: Общая идея здесь — функции/макросы, которые пользователь вызывает для работы с контейнером,
считаются частью общего API. Внутренние представления (поля `list_t`, индексы, способ выделения памяти) — нет.

## Что специфично для AOS-реализации (специфичные детали)

Ниже перечислены элементы интерфейса и структуры, которые относятся к конкретной реализации — их
изменение/удаление не нарушит саму семантику операций, но потребует адаптации кода реализации и/или
пользователей, которые полагаются на конкретные детали.

- `LIST_ERRNO` (enum) и набор ошибок (`LIST_POISON_COLLISION`, `LIST_OVERFLOW`, `LIST_LOOP_IN_NEXT` и т.д.):
  - Этот enum определён непосредственно в AOS-заголовке и отражает проверки и состояния, присущие текущей
    реализации (например, «loop in next», проверка POISON-константы и т.д.). Поэтому значения `errno` и их
    семантика являются реализационно-специфичными. Клиентский код может использовать `error(list)` и
    `verifier`, но не полагайтесь на все конкретные коды ошибок как на кросс-реализационную контрактную часть.

- Структуры и поля:
  - `list_element_t { list_containing_t data; size_t next, prev; }` — конкретный layout элементов.
  - `list_t { LIST_ERRNO errno; list_element_t *elements; size_t size, capacity, free_idx; }` — внутренние поля.
  - Эти детали предполагают индексную модель с sentinel-элементом в `elements[0]`, использование `free_idx`
    (free-list), и индексирования с 1. Другие реализации могут хранить указатели, узлы в куче и пр.

- Поведение `capacity` и индексный контракт:
  - В AOS-реализации `capacity` считается вместе с элементом `0` (sentinel). Это важная деталь при манипуляциях
    с индексами и при сравнении с `size` и `free_idx`.

- `dump`/визуализация:
  - AOS-реализация предоставляет возможности генерации dot/HTML-дампов и автоматического создания изображений —
    это удобный отладочный функционал, но конкретный формат и местоположение логов (`logs/`) — специфичны.

- Имена/утилиты с опечаткой:
  - Например, функция `list_contairing_t_comparator` содержит опечатку в имени (`contairing`), и это часть текущего API.
    Исправление имени — breaking change для кода, который на неё ссылается.

## Рекомендации для портирования/обобщения

- Если вы хотите реализовать другую версию (например, pointer-based linked-list), сохраните сигнатуры
  функций и поведение (контракт), но реализуйте внутренние поля `list_t` и `list_element_t` по-своему.
- Не делайте общим `LIST_ERRNO` если вы планируете иметь разные стратегии валидации — лучше предоставлять
  `verifier()` и `error()` и позволить реализации возвращать собственные коды/строки ошибок.
- Для кросс-реализационного API имеет смысл сформировать отдельный «портируемый» заголовок (например,
  `list/public.h`) с чистыми сигнатурами и без реализации-специфичных типов/enum'ов. AOS-специфика тогда
  останется в `list/src/aos/list_aos.h` и исходниках.

## Короткий пример (использование API)

```cpp
#include "list/src/aos/list_aos.h"
using namespace mylist_aos;

list_t *list = constructor(16);
push_back(list, 42);
dump(list, stdout, "logs", "After push_back");
destructor(&list);
```

## Где находится

- Заголовок: `list/src/aos/list_aos.h`
- Реализация: `list/src/aos/list_aos.cpp`

---

Если нужно, могу:
- добавить отдельный `list/public.h` с минимальным кросс-реализационным API;
- переместить AOS-специфичные `LIST_ERRNO` и структуры в внутренний заголовок, оставив чистый public API.

Файл сгенерирован автоматически по запросу — при желании внесу правки или расширю разделы примерами и тестами.
